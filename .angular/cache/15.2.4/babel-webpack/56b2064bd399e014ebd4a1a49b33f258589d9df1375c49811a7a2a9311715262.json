{"ast":null,"code":"import { InjectionToken, ɵɵdefineInjectable, ɵɵinject, PLATFORM_ID, Injectable, Inject, Optional, Directive, ElementRef, NgModule } from '@angular/core';\nimport { isPlatformBrowser, DOCUMENT } from '@angular/common';\nimport { coerceElement } from '@angular/cdk/coercion';\nimport { getRtlScrollAxisType } from '@angular/cdk/platform';\nimport { Subject, merge, fromEvent, Observable, animationFrameScheduler, of } from 'rxjs';\nimport { take, expand, takeWhile, takeUntil, finalize } from 'rxjs/operators';\nimport BezierEasing from 'bezier-easing';\nimport * as ɵngcc0 from '@angular/core';\nconst SMOOTH_SCROLL_OPTIONS = new InjectionToken('SMOOTH_SCROLL_OPTIONS');\n\n// @dynamic\nlet SmoothScrollManager = /*#__PURE__*/(() => {\n  class SmoothScrollManager {\n    constructor(_document, _platform, customDefaultOptions) {\n      this._document = _document;\n      this._platform = _platform;\n      // Keeps track of the ongoing SmoothScroll functions so they can be handled in case of duplication.\n      // Each scrolled element gets a destroyer stream which gets deleted immediately after it completes.\n      // Purpose: If user called a scroll function again on the same element before the scrolls completes,\n      // it cancels the ongoing scroll and starts a new one\n      this._onGoingScrolls = new Map();\n      this._defaultOptions = Object.assign({\n        duration: 468,\n        easing: {\n          x1: 0.42,\n          y1: 0,\n          x2: 0.58,\n          y2: 1\n        }\n      }, customDefaultOptions);\n    }\n    get _w() {\n      return this._document.defaultView;\n    }\n    /**\n     * Timing method\n     */\n    get _now() {\n      return this._w.performance && this._w.performance.now ? this._w.performance.now.bind(this._w.performance) : Date.now;\n    }\n    /**\n     * changes scroll position inside an element\n     */\n    _scrollElement(el, x, y) {\n      el.scrollLeft = x;\n      el.scrollTop = y;\n    }\n    /**\n     * Handles a given parameter of type HTMLElement, ElementRef or selector\n     */\n    _getElement(el, parent) {\n      if (typeof el === 'string') {\n        return (parent || this._document).querySelector(el);\n      }\n      return coerceElement(el);\n    }\n    /**\n     * Initializes a destroyer stream, re-initializes it if the element is already being scrolled\n     */\n    _initSmoothScroll(el) {\n      if (this._onGoingScrolls.has(el)) {\n        this._onGoingScrolls.get(el).next();\n      }\n      return this._onGoingScrolls.set(el, new Subject()).get(el);\n    }\n    /**\n     * Checks if smooth scroll has reached, cleans up the smooth scroll stream and resolves its promise\n     */\n    _isFinished(context, destroyed, resolve) {\n      if (context.currentX !== context.x || context.currentY !== context.y) {\n        return true;\n      }\n      destroyed.next();\n      resolve();\n      return false;\n    }\n    /**\n     * Terminates an ongoing smooth scroll\n     */\n    _interrupted(el, destroyed) {\n      return merge(fromEvent(el, 'wheel', {\n        passive: true,\n        capture: true\n      }), fromEvent(el, 'touchmove', {\n        passive: true,\n        capture: true\n      }), destroyed).pipe(take(1));\n    }\n    /**\n     * Deletes the destroyer function, runs if the smooth scroll has finished or interrupted\n     */\n    _destroy(el, destroyed) {\n      destroyed.complete();\n      this._onGoingScrolls.delete(el);\n    }\n    /**\n     * A function called recursively that, given a context, steps through scrolling\n     */\n    _step(context) {\n      return new Observable(subscriber => {\n        let elapsed = (this._now() - context.startTime) / context.duration;\n        // avoid elapsed times higher than one\n        elapsed = elapsed > 1 ? 1 : elapsed;\n        // apply easing to elapsed time\n        const value = context.easing(elapsed);\n        context.currentX = context.startX + (context.x - context.startX) * value;\n        context.currentY = context.startY + (context.y - context.startY) * value;\n        this._scrollElement(context.scrollable, context.currentX, context.currentY);\n        // Proceed to the step\n        animationFrameScheduler.schedule(() => subscriber.next(context));\n      });\n    }\n    _applyScrollToOptions(el, options) {\n      if (!options.duration) {\n        this._scrollElement(el, options.left, options.top);\n        return Promise.resolve();\n      }\n      // Initialize a destroyer stream, reinitialize it if the element is already being scrolled\n      const destroyed = this._initSmoothScroll(el);\n      const context = {\n        scrollable: el,\n        startTime: this._now(),\n        startX: el.scrollLeft,\n        startY: el.scrollTop,\n        x: options.left == null ? el.scrollLeft : ~~options.left,\n        y: options.top == null ? el.scrollTop : ~~options.top,\n        duration: options.duration,\n        easing: BezierEasing(options.easing.x1, options.easing.y1, options.easing.x2, options.easing.y2)\n      };\n      return new Promise(resolve => {\n        // Scroll each step recursively\n        of(null).pipe(expand(() => this._step(context).pipe(takeWhile(currContext => this._isFinished(currContext, destroyed, resolve)))), takeUntil(this._interrupted(el, destroyed)), finalize(() => this._destroy(el, destroyed))).subscribe();\n      });\n    }\n    /**\n     * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n     * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n     * left and right always refer to the left and right side of the scrolling container irrespective\n     * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n     * in an RTL context.\n     * @param scrollable element\n     * @param customOptions specified the offsets to scroll to.\n     */\n    scrollTo(scrollable, customOptions) {\n      if (isPlatformBrowser(this._platform)) {\n        const el = this._getElement(scrollable);\n        const isRtl = getComputedStyle(el).direction === 'rtl';\n        const rtlScrollAxisType = getRtlScrollAxisType();\n        const options = Object.assign(Object.assign(Object.assign({}, this._defaultOptions), customOptions), {\n          // Rewrite start & end offsets as right or left offsets.\n          left: customOptions.left == null ? isRtl ? customOptions.end : customOptions.start : customOptions.left,\n          right: customOptions.right == null ? isRtl ? customOptions.start : customOptions.end : customOptions.right\n        });\n        // Rewrite the bottom offset as a top offset.\n        if (options.bottom != null) {\n          options.top = el.scrollHeight - el.clientHeight - options.bottom;\n        }\n        // Rewrite the right offset as a left offset.\n        if (isRtl && rtlScrollAxisType !== 0 /* NORMAL */) {\n          if (options.left != null) {\n            options.right = el.scrollWidth - el.clientWidth - options.left;\n          }\n          if (rtlScrollAxisType === 2 /* INVERTED */) {\n            options.left = options.right;\n          } else if (rtlScrollAxisType === 1 /* NEGATED */) {\n            options.left = options.right ? -options.right : options.right;\n          }\n        } else {\n          if (options.right != null) {\n            options.left = el.scrollWidth - el.clientWidth - options.right;\n          }\n        }\n        return this._applyScrollToOptions(el, options);\n      }\n      return Promise.resolve();\n    }\n    /**\n     * Scroll to element by reference or selector\n     */\n    scrollToElement(scrollable, target, customOptions) {\n      const scrollableEl = this._getElement(scrollable);\n      const targetEl = this._getElement(target, scrollableEl);\n      const options = Object.assign(Object.assign({}, customOptions), {\n        left: targetEl.offsetLeft + (customOptions.left || 0),\n        top: targetEl.offsetTop + (customOptions.top || 0)\n      });\n      return targetEl ? this.scrollTo(scrollableEl, options) : Promise.resolve();\n    }\n  }\n  SmoothScrollManager.ɵfac = function SmoothScrollManager_Factory(t) {\n    return new (t || SmoothScrollManager)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(PLATFORM_ID), ɵngcc0.ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8));\n  };\n  SmoothScrollManager.ɵprov = ɵɵdefineInjectable({\n    factory: function SmoothScrollManager_Factory() {\n      return new SmoothScrollManager(ɵɵinject(DOCUMENT), ɵɵinject(PLATFORM_ID), ɵɵinject(SMOOTH_SCROLL_OPTIONS, 8));\n    },\n    token: SmoothScrollManager,\n    providedIn: \"root\"\n  });\n  return SmoothScrollManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SmoothScroll = /*#__PURE__*/(() => {\n  class SmoothScroll {\n    constructor(element, smoothScroll) {\n      this.element = element;\n      this.smoothScroll = smoothScroll;\n    }\n    scrollTo(options) {\n      return this.smoothScroll.scrollTo(this.element, options);\n    }\n    scrollToElement(target, options) {\n      return this.smoothScroll.scrollToElement(this.element, target, options);\n    }\n  }\n  SmoothScroll.ɵfac = function SmoothScroll_Factory(t) {\n    return new (t || SmoothScroll)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(SmoothScrollManager));\n  };\n  SmoothScroll.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: SmoothScroll,\n    selectors: [[\"\", \"smoothScroll\", \"\"], [\"\", \"smooth-scroll\", \"\"]],\n    exportAs: [\"smoothScroll\"]\n  });\n  return SmoothScroll;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SmoothScrollModule = /*#__PURE__*/(() => {\n  class SmoothScrollModule {}\n  SmoothScrollModule.ɵfac = function SmoothScrollModule_Factory(t) {\n    return new (t || SmoothScrollModule)();\n  };\n  SmoothScrollModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: SmoothScrollModule\n  });\n  SmoothScrollModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return SmoothScrollModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SmoothScrollModule, {\n    declarations: [SmoothScroll],\n    exports: [SmoothScroll]\n  });\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SMOOTH_SCROLL_OPTIONS, SmoothScroll, SmoothScrollManager, SmoothScrollModule };\n\n//# sourceMappingURL=ngx-scrollbar-smooth-scroll.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}