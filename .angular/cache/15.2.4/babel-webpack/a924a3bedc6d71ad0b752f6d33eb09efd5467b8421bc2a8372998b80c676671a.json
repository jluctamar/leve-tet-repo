{"ast":null,"code":"import { Directive, ElementRef, Inject, InjectionToken, ɵɵdefineInjectable, ɵɵinject, Injectable, Optional, EventEmitter, Component, ChangeDetectionStrategy, NgZone, ChangeDetectorRef, Input, Output, ViewChild, ContentChild, RendererStyleFlags2, Renderer2, NgModule } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Directionality, BidiModule } from '@angular/cdk/bidi';\nimport { PortalModule } from '@angular/cdk/portal';\nimport { getRtlScrollAxisType, Platform, PlatformModule } from '@angular/cdk/platform';\nimport { SmoothScrollManager, SmoothScrollModule } from 'ngx-scrollbar/smooth-scroll';\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\nimport { Observable, fromEvent, merge, Subject, BehaviorSubject, Subscription, of, from, EMPTY, animationFrameScheduler, asyncScheduler } from 'rxjs';\nimport { tap, map, takeUntil, switchMap, pluck, pairwise, filter, auditTime, debounceTime, distinctUntilChanged, catchError, mergeMap } from 'rxjs/operators';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/cdk/bidi';\nimport * as ɵngcc2 from 'ngx-scrollbar/smooth-scroll';\nimport * as ɵngcc3 from '@angular/common';\nimport * as ɵngcc4 from '@angular/cdk/platform';\nfunction NgScrollbar_ng_container_5_scrollbar_x_1_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"scrollbar-x\");\n  }\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵattribute(\"scrollable\", ctx_r1.state.isHorizontallyScrollable)(\"fit\", ctx_r1.state.verticalUsed);\n  }\n}\nfunction NgScrollbar_ng_container_5_scrollbar_y_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelement(0, \"scrollbar-y\");\n  }\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵattribute(\"scrollable\", ctx_r2.state.isVerticallyScrollable)(\"fit\", ctx_r2.state.horizontalUsed);\n  }\n}\nfunction NgScrollbar_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵelementContainerStart(0);\n    ɵngcc0.ɵɵtemplate(1, NgScrollbar_ng_container_5_scrollbar_x_1_Template, 1, 2, \"scrollbar-x\", 3);\n    ɵngcc0.ɵɵtemplate(2, NgScrollbar_ng_container_5_scrollbar_y_2_Template, 1, 2, \"scrollbar-y\", 3);\n    ɵngcc0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.state.horizontalUsed);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.state.verticalUsed);\n  }\n}\nconst _c0 = [\"*\"];\nfunction preventSelection(doc) {\n  return tap(() => {\n    doc.onselectstart = () => false;\n  });\n}\nfunction enableSelection(doc) {\n  return tap(() => {\n    doc.onselectstart = null;\n  });\n}\nfunction stopPropagation() {\n  return tap(e => e.stopPropagation());\n}\n/**\n * Check if pointer is within scrollbar bounds\n */\nfunction isWithinBounds(e, rect) {\n  return e.clientX >= rect.left && e.clientX <= rect.left + rect.width && e.clientY >= rect.top && e.clientY <= rect.top + rect.height;\n}\nlet ScrollViewport = /*#__PURE__*/(() => {\n  class ScrollViewport {\n    constructor(viewPort, document) {\n      this.viewPort = viewPort;\n      this.document = document;\n      this.nativeElement = viewPort.nativeElement;\n    }\n    // Get viewport size, clientHeight or clientWidth\n    get clientHeight() {\n      return this.nativeElement.clientHeight;\n    }\n    get clientWidth() {\n      return this.nativeElement.clientWidth;\n    }\n    get scrollHeight() {\n      return this.nativeElement.scrollHeight;\n    }\n    get scrollWidth() {\n      return this.nativeElement.scrollWidth;\n    }\n    // Get viewport scroll offset, scrollTop or scrollLeft\n    get scrollTop() {\n      return this.nativeElement.scrollTop;\n    }\n    get scrollLeft() {\n      return this.nativeElement.scrollLeft;\n    }\n    // Get the available scrollable size\n    get scrollMaxX() {\n      return this.scrollWidth - this.clientWidth;\n    }\n    get scrollMaxY() {\n      return this.scrollHeight - this.clientHeight;\n    }\n    get contentHeight() {\n      return this.contentWrapperElement.clientHeight;\n    }\n    /**\n     * Activate viewport pointer events such as 'hovered' and 'clicked' events\n     */\n    activatePointerEvents(propagate, destroyed) {\n      this.hovered = new Observable(subscriber => {\n        // Stream that emits when pointer is moved over the viewport (used to set the hovered state)\n        const mouseMoveStream = fromEvent(this.nativeElement, 'mousemove', {\n          passive: true\n        });\n        const mouseMove = propagate ? mouseMoveStream : mouseMoveStream.pipe(stopPropagation());\n        // Stream that emits when pointer leaves the viewport (used to remove the hovered state)\n        const mouseLeave = fromEvent(this.nativeElement, 'mouseleave').pipe(map(() => false));\n        merge(mouseMove, mouseLeave).pipe(tap(e => subscriber.next(e)), takeUntil(destroyed)).subscribe();\n      });\n      this.clicked = new Observable(subscriber => {\n        const mouseDown = fromEvent(this.nativeElement, 'mousedown', {\n          passive: true\n        }).pipe(tap(e => subscriber.next(e)));\n        const mouseUp = fromEvent(this.nativeElement, 'mouseup', {\n          passive: true\n        }).pipe(tap(() => subscriber.next(false)));\n        mouseDown.pipe(switchMap(() => mouseUp), takeUntil(destroyed)).subscribe();\n      });\n    }\n    /**\n     * Set this directive as a non-functional wrapper, called when a custom viewport is used\n     */\n    setAsWrapper() {\n      // In this case the default viewport and the default content wrapper will act as a mask\n      this.nativeElement.className = 'ng-native-scrollbar-hider ng-scroll-layer';\n      if (this.nativeElement.firstElementChild) {\n        this.nativeElement.firstElementChild.className = 'ng-scroll-layer';\n      }\n    }\n    /**\n     * Set this directive as  the viewport, called when no custom viewport is used\n     */\n    setAsViewport(customClassName) {\n      this.nativeElement.className = `ng-native-scrollbar-hider ng-scroll-viewport ${customClassName}`;\n      // Check if the custom viewport has only one child and set it as the content wrapper\n      if (this.nativeElement.firstElementChild) {\n        this.contentWrapperElement = this.nativeElement.firstElementChild;\n        this.contentWrapperElement.classList.add('ng-scroll-content');\n      }\n    }\n    /**\n     * Scroll viewport vertically\n     */\n    scrollYTo(value) {\n      this.nativeElement.scrollTop = value;\n    }\n    /**\n     * Scroll viewport horizontally\n     */\n    scrollXTo(value) {\n      this.nativeElement.scrollLeft = value;\n    }\n  }\n  ScrollViewport.ɵfac = function ScrollViewport_Factory(t) {\n    return new (t || ScrollViewport)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n  ScrollViewport.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ScrollViewport,\n    selectors: [[\"\", \"scrollViewport\", \"\"]]\n  });\n  return ScrollViewport;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NG_SCROLLBAR_OPTIONS = new InjectionToken('NG_SCROLLBAR_OPTIONS');\nconst defaultOptions = {\n  viewClass: '',\n  trackClass: '',\n  thumbClass: '',\n  track: 'vertical',\n  appearance: 'compact',\n  visibility: 'native',\n  position: 'native',\n  pointerEventsMethod: 'viewport',\n  trackClickScrollDuration: 300,\n  minThumbSize: 20,\n  windowResizeDebounce: 0,\n  sensorDebounce: 0,\n  scrollAuditTime: 0,\n  viewportPropagateMouseMove: true\n};\nlet ScrollbarManager = /*#__PURE__*/(() => {\n  class ScrollbarManager {\n    constructor(options) {\n      this.globalOptions = options ? Object.assign(Object.assign({}, defaultOptions), options) : defaultOptions;\n      this.rtlScrollAxisType = getRtlScrollAxisType();\n    }\n  }\n  ScrollbarManager.ɵfac = function ScrollbarManager_Factory(t) {\n    return new (t || ScrollbarManager)(ɵngcc0.ɵɵinject(NG_SCROLLBAR_OPTIONS, 8));\n  };\n  ScrollbarManager.ɵprov = ɵɵdefineInjectable({\n    factory: function ScrollbarManager_Factory() {\n      return new ScrollbarManager(ɵɵinject(NG_SCROLLBAR_OPTIONS, 8));\n    },\n    token: ScrollbarManager,\n    providedIn: \"root\"\n  });\n  return ScrollbarManager;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgScrollbar = /*#__PURE__*/(() => {\n  class NgScrollbar {\n    constructor(el, zone, changeDetectorRef, dir, smoothScroll, manager) {\n      this.el = el;\n      this.zone = zone;\n      this.changeDetectorRef = changeDetectorRef;\n      this.dir = dir;\n      this.smoothScroll = smoothScroll;\n      this.manager = manager;\n      this._disabled = false;\n      this._sensorDisabled = this.manager.globalOptions.sensorDisabled;\n      this._pointerEventsDisabled = this.manager.globalOptions.pointerEventsDisabled;\n      this._viewportPropagateMouseMove = this.manager.globalOptions.viewportPropagateMouseMove;\n      /** A class forwarded to scrollable viewport element */\n      this.viewClass = this.manager.globalOptions.viewClass;\n      /** A class forwarded to the scrollbar track element */\n      this.trackClass = this.manager.globalOptions.trackClass;\n      /** A class forwarded to the scrollbar thumb element */\n      this.thumbClass = this.manager.globalOptions.thumbClass;\n      /** Minimum scrollbar thumb size */\n      this.minThumbSize = this.manager.globalOptions.minThumbSize;\n      /** The duration which the scrolling takes to reach its target when scrollbar rail is clicked */\n      this.trackClickScrollDuration = this.manager.globalOptions.trackClickScrollDuration;\n      /**\n       * Sets the pointer events method\n       * Use viewport pointer events  to handle dragging and track click (This makes scrolling work when mouse is over the scrollbar)\n       * Use scrollbar pointer events to handle dragging and track click\n       */\n      this.pointerEventsMethod = this.manager.globalOptions.pointerEventsMethod;\n      /**\n       * Sets the supported scroll track of the viewport, there are 3 options:\n       *\n       * - `vertical` Use both vertical and horizontal scrollbar\n       * - `horizontal` Use both vertical and horizontal scrollbar\n       * - `all` Use both vertical and horizontal scrollbar\n       */\n      this.track = this.manager.globalOptions.track;\n      /**\n       * When to show the scrollbar, and there are 3 options:\n       *\n       * - `native` (default) Scrollbar will be visible when viewport is scrollable like with native scrollbar\n       * - `hover` Scrollbars are hidden by default, only visible on scrolling or hovering\n       * - `always` Scrollbars are always shown even if the viewport is not scrollable\n       */\n      this.visibility = this.manager.globalOptions.visibility;\n      /**\n       *  Sets the appearance of the scrollbar, there are 2 options:\n       *\n       * - `standard` (default) scrollbar space will be reserved just like with native scrollbar.\n       * - `compact` scrollbar doesn't reserve any space, they are placed over the viewport.\n       */\n      this.appearance = this.manager.globalOptions.appearance;\n      /**\n       * Sets the position of each scrollbar, there are 4 options:\n       *\n       * - `native` (Default) Use the default position like in native scrollbar.\n       * - `invertY` Inverts vertical scrollbar position\n       * - `invertX` Inverts Horizontal scrollbar position\n       * - `invertAll` Inverts both scrollbar positions\n       */\n      this.position = this.manager.globalOptions.position;\n      /** Debounce interval for detecting changes via ResizeObserver */\n      this.sensorDebounce = this.manager.globalOptions.sensorDebounce;\n      /** Scroll Audit Time */\n      this.scrollAuditTime = this.manager.globalOptions.scrollAuditTime;\n      /** Steam that emits when scrollbar is updated */\n      this.updated = new EventEmitter();\n      /** Set of attributes added on the scrollbar wrapper */\n      this.state = {};\n      /** Stream that destroys components' observables */\n      this.destroyed = new Subject();\n    }\n    /** Disable custom scrollbar and switch back to native scrollbar */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(disabled) {\n      this._disabled = coerceBooleanProperty(disabled);\n    }\n    /** Whether ResizeObserver is disabled */\n    get sensorDisabled() {\n      return this._sensorDisabled;\n    }\n    set sensorDisabled(disabled) {\n      this._sensorDisabled = coerceBooleanProperty(disabled);\n    }\n    /** A flag used to enable/disable the scrollbar thumb dragged event */\n    get pointerEventsDisabled() {\n      return this._pointerEventsDisabled;\n    }\n    set pointerEventsDisabled(disabled) {\n      this._pointerEventsDisabled = coerceBooleanProperty(disabled);\n    }\n    /** Enable viewport mousemove event propagation (only when pointerEventsMethod=\"viewport\") */\n    get viewportPropagateMouseMove() {\n      return this._viewportPropagateMouseMove;\n    }\n    set viewportPropagateMouseMove(disabled) {\n      this._viewportPropagateMouseMove = coerceBooleanProperty(disabled);\n    }\n    get nativeElement() {\n      return this.el.nativeElement;\n    }\n    /**\n     * Update local state with each change detection\n     */\n    updateState() {\n      let verticalUsed = false;\n      let horizontalUsed = false;\n      let isVerticallyScrollable = false;\n      let isHorizontallyScrollable = false;\n      // Check if vertical scrollbar should be displayed\n      if (this.track === 'all' || this.track === 'vertical') {\n        isVerticallyScrollable = this.viewport.scrollHeight > this.viewport.clientHeight;\n        verticalUsed = this.visibility === 'always' || isVerticallyScrollable;\n      }\n      // Check if horizontal scrollbar should be displayed\n      if (this.track === 'all' || this.track === 'horizontal') {\n        isHorizontallyScrollable = this.viewport.scrollWidth > this.viewport.clientWidth;\n        horizontalUsed = this.visibility === 'always' || isHorizontallyScrollable;\n      }\n      // Update inner wrapper attributes\n      this._updateState({\n        position: this.position,\n        track: this.track,\n        appearance: this.appearance,\n        visibility: this.visibility,\n        deactivated: this.disabled,\n        dir: this.dir.value,\n        pointerEventsMethod: this.pointerEventsMethod,\n        verticalUsed,\n        horizontalUsed,\n        isVerticallyScrollable,\n        isHorizontallyScrollable\n      });\n    }\n    _updateState(state) {\n      this.state = Object.assign(Object.assign({}, this.state), state);\n      this.changeDetectorRef.detectChanges();\n    }\n    getScrolledByDirection(property) {\n      let event;\n      return this.scrolled.pipe(tap(e => event = e), pluck('target', property), pairwise(), filter(([prev, curr]) => prev !== curr), map(() => event));\n    }\n    /**\n     * Set hovered state if a scrollbar is being hovered\n     */\n    setHovered(hovered) {\n      this.zone.run(() => this._updateState(Object.assign({}, hovered)));\n    }\n    /**\n     * Set dragging state if a scrollbar is being dragged\n     */\n    setDragging(dragging) {\n      this.zone.run(() => this._updateState(Object.assign({}, dragging)));\n    }\n    /**\n     * Set clicked state if a scrollbar track is being click\n     */\n    setClicked(scrollbarClicked) {\n      this.zone.run(() => this._updateState({\n        scrollbarClicked\n      }));\n    }\n    ngOnInit() {\n      // Set the viewport based on user choice\n      this.zone.runOutsideAngular(() => {\n        if (this.customViewPort) {\n          this.viewport = this.customViewPort;\n          this.defaultViewPort.setAsWrapper();\n        } else {\n          this.viewport = this.defaultViewPort;\n        }\n        // Activate the selected viewport\n        this.viewport.setAsViewport(this.viewClass);\n        let scrollStream = fromEvent(this.viewport.nativeElement, 'scroll', {\n          passive: true\n        });\n        // Throttle scroll event if 'scrollAuditTime' is set\n        scrollStream = this.scrollAuditTime ? scrollStream.pipe(auditTime(this.scrollAuditTime)) : scrollStream;\n        // Initialize scroll streams\n        this.scrolled = new Observable(subscriber => scrollStream.pipe(takeUntil(this.destroyed)).subscribe(subscriber));\n        this.verticalScrolled = this.getScrolledByDirection('scrollTop');\n        this.horizontalScrolled = this.getScrolledByDirection('scrollLeft');\n      });\n    }\n    ngAfterViewChecked() {\n      this.updateState();\n    }\n    ngOnDestroy() {\n      this.destroyed.next();\n      this.destroyed.complete();\n    }\n    /**\n     * Update local state and the internal scrollbar controls\n     */\n    update() {\n      if (!this.state.horizontalUsed) {\n        // Auto-height: Set component height to content height\n        this.nativeElement.style.height = `${this.viewport.contentHeight}px`;\n      }\n      this.updated.next();\n      this.changeDetectorRef.detectChanges();\n    }\n    /**\n     * Smooth scroll functions\n     */\n    scrollTo(options) {\n      return this.smoothScroll.scrollTo(this.viewport.nativeElement, options);\n    }\n    /**\n     * Scroll to element by reference or selector\n     */\n    scrollToElement(target, options) {\n      return this.smoothScroll.scrollToElement(this.viewport.nativeElement, target, options);\n    }\n  }\n  NgScrollbar.ɵfac = function NgScrollbar_Factory(t) {\n    return new (t || NgScrollbar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.SmoothScrollManager), ɵngcc0.ɵɵdirectiveInject(ScrollbarManager));\n  };\n  NgScrollbar.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgScrollbar,\n    selectors: [[\"ng-scrollbar\"]],\n    contentQueries: function NgScrollbar_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, ScrollViewport, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.customViewPort = _t.first);\n      }\n    },\n    viewQuery: function NgScrollbar_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(ScrollViewport, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultViewPort = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function NgScrollbar_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"ng-scrollbar\", true);\n      }\n    },\n    inputs: {\n      viewClass: \"viewClass\",\n      trackClass: \"trackClass\",\n      thumbClass: \"thumbClass\",\n      minThumbSize: \"minThumbSize\",\n      trackClickScrollDuration: \"trackClickScrollDuration\",\n      pointerEventsMethod: \"pointerEventsMethod\",\n      track: \"track\",\n      visibility: \"visibility\",\n      appearance: \"appearance\",\n      position: \"position\",\n      sensorDebounce: \"sensorDebounce\",\n      scrollAuditTime: \"scrollAuditTime\",\n      disabled: \"disabled\",\n      sensorDisabled: \"sensorDisabled\",\n      pointerEventsDisabled: \"pointerEventsDisabled\",\n      viewportPropagateMouseMove: \"viewportPropagateMouseMove\"\n    },\n    outputs: {\n      updated: \"updated\"\n    },\n    exportAs: [\"ngScrollbar\"],\n    ngContentSelectors: _c0,\n    decls: 6,\n    vars: 4,\n    consts: [[1, \"ng-scrollbar-wrapper\", 3, \"ngAttr\"], [1, \"ng-scroll-viewport-wrapper\", 3, \"sensorDebounce\", \"sensorDisabled\", \"resizeSensor\"], [\"scrollViewport\", \"\", \"hideNativeScrollbar\", \"\"], [4, \"ngIf\"]],\n    template: function NgScrollbar_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n        ɵngcc0.ɵɵlistener(\"resizeSensor\", function NgScrollbar_Template_div_resizeSensor_1_listener() {\n          return ctx.update();\n        });\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2)(3, \"div\");\n        ɵngcc0.ɵɵprojection(4);\n        ɵngcc0.ɵɵelementEnd()()();\n        ɵngcc0.ɵɵtemplate(5, NgScrollbar_ng_container_5_Template, 3, 2, \"ng-container\", 3);\n        ɵngcc0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"ngAttr\", ctx.state);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"sensorDebounce\", ctx.sensorDebounce)(\"sensorDisabled\", ctx.sensorDisabled);\n        ɵngcc0.ɵɵadvance(4);\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx.disabled);\n      }\n    },\n    dependencies: function () {\n      return [ɵngcc3.NgIf, ScrollViewport, HideNativeScrollbar, NgAttr, ResizeSensor, ScrollbarY, ScrollbarX];\n    },\n    styles: [\".ng-scrollbar-measure{-ms-overflow-style:none;left:0;overflow:scroll;position:fixed;scrollbar-width:none;top:-9999px}  .ng-scrollbar-measure::-webkit-scrollbar{display:none}[_nghost-%COMP%]{--scrollbar-border-radius:7px;--scrollbar-hover-size:var(--scrollbar-size);--scrollbar-padding:4px;--scrollbar-size:5px;--scrollbar-thumb-color:rgba(0,0,0,0.2);--scrollbar-thumb-hover-color:var(--scrollbar-thumb-color);--scrollbar-thumb-transition:height ease-out 150ms,width ease-out 150ms;--scrollbar-track-color:transparent;--scrollbar-track-transition:height ease-out 150ms,width ease-out 150ms;display:block;height:100%;max-height:100%;max-width:100%;position:relative}[_nghost-%COMP%] > .ng-scrollbar-wrapper[_ngcontent-%COMP%]{--horizontal-scrollbar-size:var(--scrollbar-size);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding)*2);--scrollbar-total-size:calc(var(--scrollbar-size) + var(--scrollbar-padding)*2);--vertical-scrollbar-size:var(--scrollbar-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding)*2)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalDragging=true][_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalHovered=true][_ngcontent-%COMP%]{--vertical-scrollbar-size:var(--scrollbar-hover-size);--vertical-scrollbar-total-size:calc(var(--vertical-scrollbar-size) + var(--scrollbar-padding)*2);cursor:default}[_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalDragging=true][_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalHovered=true][_ngcontent-%COMP%]{--horizontal-scrollbar-size:var(--scrollbar-hover-size);--horizontal-scrollbar-total-size:calc(var(--horizontal-scrollbar-size) + var(--scrollbar-padding)*2);cursor:default}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:0;right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:var(--scrollbar-total-size);right:0}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-left:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:var(--scrollbar-total-size);right:0}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=ltr][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-left:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{left:0;right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertAll][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][verticalUsed=true][position=invertY][dir=rtl][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-right:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{bottom:var(--scrollbar-total-size);top:0}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-bottom:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=scrollbar][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{bottom:0;top:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertAll][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][appearance=standard][horizontalUsed=true][position=invertX][pointerEventsMethod=viewport][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{padding-top:var(--scrollbar-total-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{-ms-overflow-style:none;scrollbar-width:none}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport::-webkit-scrollbar, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]::-webkit-scrollbar{display:none}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-native-scrollbar-hider, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-native-scrollbar-hider[_ngcontent-%COMP%]{bottom:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-native-scrollbar-hider, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-native-scrollbar-hider[_ngcontent-%COMP%]{left:0;right:var(--native-scrollbar-size)}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-native-scrollbar-hider, [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][verticalUsed=true][dir=rtl][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-native-scrollbar-hider[_ngcontent-%COMP%]{left:var(--native-scrollbar-size);right:0}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%] > .scrollbar-control[_ngcontent-%COMP%]{opacity:0;transition-delay:.8s;transition-duration:.4s;transition-property:opacity}[_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%]:active > .scrollbar-control[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%]:focus > .scrollbar-control[_ngcontent-%COMP%], [_nghost-%COMP%] > .ng-scrollbar-wrapper[deactivated=false][visibility=hover][_ngcontent-%COMP%]:hover > .scrollbar-control[_ngcontent-%COMP%]{opacity:1;transition-delay:0ms;transition-duration:.4s}[_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{overflow-x:auto;overflow-y:hidden}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{overflow-x:hidden;overflow-y:auto}[_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] > *[_ngcontent-%COMP%] >  .ng-scroll-viewport, [_nghost-%COMP%] > .ng-scrollbar-wrapper[verticalUsed=true][horizontalUsed=true][_ngcontent-%COMP%] > .ng-scroll-viewport-wrapper[_ngcontent-%COMP%] > .ng-scroll-viewport[_ngcontent-%COMP%]{overflow:auto}.ng-scroll-viewport-wrapper[_ngcontent-%COMP%]{overflow:hidden}.ng-scroll-viewport[_ngcontent-%COMP%]{-webkit-overflow-scrolling:touch;contain:strict;will-change:scroll-position}  .ng-scroll-content{display:inline-block;min-width:100%;position:relative!important}.ng-scroll-layer[_ngcontent-%COMP%], .ng-scroll-viewport-wrapper[_ngcontent-%COMP%], .ng-scrollbar-wrapper[_ngcontent-%COMP%],   .ng-scroll-viewport{bottom:0;left:0;position:absolute;right:0;top:0}\", \".ng-scrollbar-wrapper[pointerEventsMethod=viewport]>.scrollbar-control{pointer-events:none}  .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>*>*> .ng-scroll-viewport,   .ng-scrollbar-wrapper[horizontalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,   .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>*>*> .ng-scroll-viewport,   .ng-scrollbar-wrapper[scrollbarClicked=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport,   .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>*>*> .ng-scroll-viewport,   .ng-scrollbar-wrapper[verticalDragging=true]>.ng-scroll-viewport-wrapper>.ng-scroll-viewport{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none}  .ng-scrollbar-wrapper>.scrollbar-control{align-items:center;display:flex;justify-content:center;position:absolute;transition:var(--scrollbar-track-transition)}  .ng-scrollbar-wrapper>.scrollbar-control[scrollable=false] .ng-scrollbar-thumb{display:none}  .ng-scrollbar-track{background-color:var(--scrollbar-track-color);border-radius:var(--scrollbar-border-radius);cursor:default;height:100%;overflow:hidden;transition:var(--scrollbar-track-transition);width:100%;z-index:1}  .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-color);border-radius:inherit;box-sizing:border-box;position:relative;transform:translateZ(0);transition:var(--scrollbar-thumb-transition)}\"],\n    changeDetection: 0\n  });\n  return NgScrollbar;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NativeScrollbarSizeFactory = /*#__PURE__*/(() => {\n  class NativeScrollbarSizeFactory {\n    constructor(document, manager, platform) {\n      this.document = document;\n      this.manager = manager;\n      this.platform = platform;\n      this._scrollbarSize = new BehaviorSubject(this.getNativeScrollbarSize());\n      this.scrollbarSize = this._scrollbarSize.asObservable();\n      // Calculate native scrollbar size on window resize event, because the size changes if use zoomed in/out\n      if (platform.isBrowser) {\n        fromEvent(this.document.defaultView, 'resize', {\n          passive: true\n        }).pipe(debounceTime(this.manager.globalOptions.windowResizeDebounce), map(() => this.getNativeScrollbarSize()), distinctUntilChanged(), tap(size => this._scrollbarSize.next(size))).subscribe();\n      }\n    }\n    /**\n     * Get native scrollbar size\n     */\n    getNativeScrollbarSize() {\n      // Avoid executing browser code in server side rendering\n      if (!this.platform.isBrowser) {\n        return 0;\n      }\n      // Hide iOS browsers native scrollbar\n      if (this.platform.IOS) {\n        return 6;\n      }\n      const box = this.document.createElement('div');\n      box.className = 'ng-scrollbar-measure';\n      this.document.body.appendChild(box);\n      const size = box.getBoundingClientRect().right;\n      this.document.body.removeChild(box);\n      return size;\n    }\n  }\n  NativeScrollbarSizeFactory.ɵfac = function NativeScrollbarSizeFactory_Factory(t) {\n    return new (t || NativeScrollbarSizeFactory)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ScrollbarManager), ɵngcc0.ɵɵinject(ɵngcc4.Platform));\n  };\n  NativeScrollbarSizeFactory.ɵprov = ɵɵdefineInjectable({\n    factory: function NativeScrollbarSizeFactory_Factory() {\n      return new NativeScrollbarSizeFactory(ɵɵinject(DOCUMENT), ɵɵinject(ScrollbarManager), ɵɵinject(Platform));\n    },\n    token: NativeScrollbarSizeFactory,\n    providedIn: \"root\"\n  });\n  return NativeScrollbarSizeFactory;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet HideNativeScrollbar = /*#__PURE__*/(() => {\n  class HideNativeScrollbar {\n    constructor(el, renderer, hideNativeScrollbar) {\n      this.renderer = renderer;\n      this.hideNativeScrollbar = hideNativeScrollbar;\n      this._subscriber = Subscription.EMPTY;\n      this._subscriber = hideNativeScrollbar.scrollbarSize.subscribe(size => {\n        this.renderer.setStyle(el.nativeElement, '--native-scrollbar-size', `-${size}px`, RendererStyleFlags2.DashCase);\n      });\n    }\n    ngOnDestroy() {\n      this._subscriber.unsubscribe();\n    }\n  }\n  HideNativeScrollbar.ɵfac = function HideNativeScrollbar_Factory(t) {\n    return new (t || HideNativeScrollbar)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(NativeScrollbarSizeFactory));\n  };\n  HideNativeScrollbar.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: HideNativeScrollbar,\n    selectors: [[\"\", \"hideNativeScrollbar\", \"\"]]\n  });\n  return HideNativeScrollbar;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgAttr = /*#__PURE__*/(() => {\n  class NgAttr {\n    constructor(el) {\n      this.el = el;\n    }\n    set ngAttr(attrs) {\n      for (const [key, value] of Object.entries(attrs)) {\n        this.el.nativeElement.setAttribute(key, value);\n      }\n    }\n  }\n  NgAttr.ɵfac = function NgAttr_Factory(t) {\n    return new (t || NgAttr)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef));\n  };\n  NgAttr.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: NgAttr,\n    selectors: [[\"\", \"ngAttr\", \"\"]],\n    inputs: {\n      ngAttr: \"ngAttr\"\n    }\n  });\n  return NgAttr;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Factory that initialize the ResizeObserver if available in the browser\n * Otherwise, it lazy-loads the ResizeObserver polyfill\n */\nlet ResizeObserverFactory = /*#__PURE__*/(() => {\n  class ResizeObserverFactory {\n    constructor(document, platform) {\n      this.resizeObserverSource = new BehaviorSubject(null);\n      this.resizeObserverLoader = this.resizeObserverSource.asObservable();\n      if (platform.isBrowser) {\n        const resizeObserverApi = document.defaultView.ResizeObserver ? of(document.defaultView.ResizeObserver) : from(import('@juggle/resize-observer')).pipe(map(module => module.ResizeObserver), catchError(e => {\n          console.log('Unable to load ResizeObserver polyfill', e);\n          return EMPTY;\n        }));\n        this.resizeObserverSource.next(resizeObserverApi);\n      }\n    }\n  }\n  ResizeObserverFactory.ɵfac = function ResizeObserverFactory_Factory(t) {\n    return new (t || ResizeObserverFactory)(ɵngcc0.ɵɵinject(DOCUMENT), ɵngcc0.ɵɵinject(ɵngcc4.Platform));\n  };\n  ResizeObserverFactory.ɵprov = ɵɵdefineInjectable({\n    factory: function ResizeObserverFactory_Factory() {\n      return new ResizeObserverFactory(ɵɵinject(DOCUMENT), ɵɵinject(Platform));\n    },\n    token: ResizeObserverFactory,\n    providedIn: \"root\"\n  });\n  return ResizeObserverFactory;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ResizeSensor = /*#__PURE__*/(() => {\n  class ResizeSensor {\n    constructor(zone, platform, resizeObserverFactory, scrollbar) {\n      this.zone = zone;\n      this.platform = platform;\n      this.resizeObserverFactory = resizeObserverFactory;\n      this.scrollbar = scrollbar;\n      this._disabled = false;\n      this._subscription = null;\n      this.resizeSensor = new EventEmitter();\n      if (!scrollbar) {\n        throw new Error('[NgScrollbar Resize Sensor Directive]: Host element must be an NgScrollbar component.');\n      }\n    }\n    /** Debounce interval for emitting the changes. */\n    get debounce() {\n      return this._debounce;\n    }\n    set debounce(value) {\n      this._debounce = coerceNumberProperty(value);\n      this._subscribe();\n    }\n    /** Whether ResizeObserver is disabled. */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n      this._disabled ? this._unsubscribe() : this._subscribe();\n    }\n    ngAfterContentInit() {\n      if (!this._subscription && !this._disabled) {\n        this._subscribe();\n      }\n    }\n    ngOnDestroy() {\n      this._unsubscribe();\n    }\n    _createObserver(ResizeObserver) {\n      return new Observable(observer => {\n        this._resizeObserver = new ResizeObserver(() => observer.next());\n        this._resizeObserver.observe(this.scrollbar.viewport.nativeElement);\n        if (this.scrollbar.viewport.contentWrapperElement) {\n          this._resizeObserver.observe(this.scrollbar.viewport.contentWrapperElement);\n        }\n      });\n    }\n    _subscribe() {\n      this._unsubscribe();\n      if (this.platform.isBrowser) {\n        this.zone.runOutsideAngular(() => {\n          this._subscription = this.resizeObserverFactory.resizeObserverLoader.pipe(switchMap(moduleObservable => moduleObservable), switchMap(ResizeObserver => {\n            if (ResizeObserver) {\n              const stream = this._createObserver(ResizeObserver);\n              return this.debounce ? stream.pipe(debounceTime(this._debounce)) : stream;\n            } else {\n              return EMPTY;\n            }\n          })).subscribe(() => this.resizeSensor.emit());\n        });\n      }\n    }\n    _unsubscribe() {\n      if (this._resizeObserver) {\n        this._resizeObserver.disconnect();\n      }\n      if (this._subscription) {\n        this._subscription.unsubscribe();\n      }\n    }\n  }\n  ResizeSensor.ɵfac = function ResizeSensor_Factory(t) {\n    return new (t || ResizeSensor)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Platform), ɵngcc0.ɵɵdirectiveInject(ResizeObserverFactory), ɵngcc0.ɵɵdirectiveInject(NgScrollbar));\n  };\n  ResizeSensor.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ResizeSensor,\n    selectors: [[\"\", \"resizeSensor\", \"\"]],\n    inputs: {\n      debounce: [\"sensorDebounce\", \"debounce\"],\n      disabled: [\"sensorDisabled\", \"disabled\"]\n    },\n    outputs: {\n      resizeSensor: \"resizeSensor\"\n    }\n  });\n  return ResizeSensor;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// @dynamic\nlet TrackAdapter = /*#__PURE__*/(() => {\n  class TrackAdapter {\n    constructor(cmp, trackElement, document) {\n      this.cmp = cmp;\n      this.trackElement = trackElement;\n      this.document = document;\n    }\n    // Stream that emits when the track element is clicked\n    get clicked() {\n      const mouseDown = fromEvent(this.trackElement, 'mousedown', {\n        passive: true\n      }).pipe(stopPropagation(), preventSelection(this.document));\n      const mouseup = fromEvent(this.document, 'mouseup', {\n        passive: true\n      }).pipe(stopPropagation(), enableSelection(this.document), switchMap(() => EMPTY));\n      return merge(mouseDown, mouseup);\n    }\n    // Stream that emits when the track element is hovered\n    get hovered() {\n      const mouseEnter = fromEvent(this.trackElement, 'mouseenter', {\n        passive: true\n      }).pipe(stopPropagation(), map(() => true));\n      const mouseLeave = fromEvent(this.trackElement, 'mouseleave', {\n        passive: true\n      }).pipe(stopPropagation(), map(() => false));\n      return merge(mouseEnter, mouseLeave);\n    }\n    // Get track client rect\n    get clientRect() {\n      return this.trackElement.getBoundingClientRect();\n    }\n    /**\n     * Stream that emits when scrollbar track is clicked\n     */\n    onTrackClicked(e, thumbSize, scrollSize) {\n      return of(e).pipe(pluck(this.pageProperty),\n      // Calculate scrollTo position\n      map(pageOffset => {\n        const clickOffset = pageOffset - this.offset;\n        const offset = clickOffset - thumbSize / 2;\n        const ratio = offset / this.size;\n        return ratio * scrollSize;\n      }),\n      // Smooth scroll to position\n      tap(value => {\n        this.cmp.scrollTo(Object.assign(Object.assign({}, this.mapToScrollToOption(value)), {\n          duration: coerceNumberProperty(this.cmp.trackClickScrollDuration)\n        }));\n      }));\n    }\n  }\n  TrackAdapter.ɵfac = function TrackAdapter_Factory(t) {\n    return new (t || TrackAdapter)(ɵngcc0.ɵɵdirectiveInject(NgScrollbar), ɵngcc0.ɵɵdirectiveInject(HTMLElement), ɵngcc0.ɵɵdirectiveInject(undefined));\n  };\n  TrackAdapter.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TrackAdapter\n  });\n  return TrackAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n// @dynamic\nlet ThumbAdapter = /*#__PURE__*/(() => {\n  class ThumbAdapter {\n    constructor(cmp, thumbElement, document) {\n      this.cmp = cmp;\n      this.thumbElement = thumbElement;\n      this.document = document;\n      // Stream that emits dragging state\n      this._dragging = new Subject();\n      this.dragging = this._dragging.pipe(distinctUntilChanged());\n    }\n    get trackMax() {\n      return this.track.size - this.size;\n    }\n    // Get thumb client rect\n    get clientRect() {\n      return this.thumbElement.getBoundingClientRect();\n    }\n    // Stream that emits when scrollbar thumb is clicked\n    get clicked() {\n      return fromEvent(this.thumbElement, 'mousedown', {\n        passive: true\n      }).pipe(stopPropagation());\n    }\n    // Calculate and update thumb position and size\n    update() {\n      const size = calculateThumbSize(this.track.size, this.viewportScrollSize, this.cmp.minThumbSize);\n      const position = calculateThumbPosition(this.viewportScrollOffset, this.viewportScrollMax, this.trackMax);\n      animationFrameScheduler.schedule(() => this.updateStyles(this.handleDirection(position, this.trackMax), size));\n    }\n    /**\n     * Stream that emits the 'scrollTo' position when a scrollbar thumb element is dragged\n     * This function is called by thumb drag event using viewport or scrollbar pointer events\n     */\n    dragged(event) {\n      let trackMaxStart;\n      let scrollMaxStart;\n      const dragStart = of(event).pipe(preventSelection(this.document), tap(() => {\n        // Capture scrollMax and trackMax once\n        trackMaxStart = this.trackMax;\n        scrollMaxStart = this.viewportScrollMax;\n        this.setDragging(true);\n      }));\n      const dragging = fromEvent(this.document, 'mousemove', {\n        capture: true,\n        passive: true\n      }).pipe(stopPropagation());\n      const dragEnd = fromEvent(this.document, 'mouseup', {\n        capture: true\n      }).pipe(stopPropagation(), enableSelection(this.document), tap(() => this.setDragging(false)));\n      return dragStart.pipe(pluck(this.pageProperty), map(pageOffset => pageOffset - this.dragStartOffset), mergeMap(mouseDownOffset => dragging.pipe(pluck(this.clientProperty),\n      // Calculate how far the pointer is from the top/left of the scrollbar (minus the dragOffset).\n      map(mouseOffset => mouseOffset - this.track.offset), map(offset => scrollMaxStart * (offset - mouseDownOffset) / trackMaxStart), map(position => this.handleDrag(position, scrollMaxStart)), tap(position => this.scrollTo(position)), takeUntil(dragEnd))));\n    }\n  }\n  ThumbAdapter.ɵfac = function ThumbAdapter_Factory(t) {\n    return new (t || ThumbAdapter)(ɵngcc0.ɵɵdirectiveInject(NgScrollbar), ɵngcc0.ɵɵdirectiveInject(HTMLElement), ɵngcc0.ɵɵdirectiveInject(undefined));\n  };\n  ThumbAdapter.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ThumbAdapter,\n    inputs: {\n      track: \"track\"\n    },\n    outputs: {\n      dragging: \"dragging\"\n    }\n  });\n  return ThumbAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Calculate scrollbar thumb size\n */\nfunction calculateThumbSize(trackSize, contentSize, minThumbSize) {\n  const scrollbarRatio = trackSize / contentSize;\n  const thumbSize = scrollbarRatio * trackSize;\n  return Math.max(~~thumbSize, minThumbSize);\n}\n/**\n * Calculate scrollbar thumb position\n */\nfunction calculateThumbPosition(scrollPosition, scrollMax, trackMax) {\n  return scrollPosition * trackMax / scrollMax;\n}\nlet ThumbXDirective = /*#__PURE__*/(() => {\n  class ThumbXDirective extends ThumbAdapter {\n    constructor(cmp, element, document, dir) {\n      super(cmp, element.nativeElement, document);\n      this.cmp = cmp;\n      this.element = element;\n      this.document = document;\n      this.dir = dir;\n    }\n    get clientProperty() {\n      return 'clientX';\n    }\n    get pageProperty() {\n      return 'pageX';\n    }\n    get viewportScrollSize() {\n      return this.cmp.viewport.scrollWidth;\n    }\n    get viewportScrollOffset() {\n      return this.cmp.viewport.scrollLeft;\n    }\n    get viewportScrollMax() {\n      return this.cmp.viewport.scrollMaxX;\n    }\n    get dragStartOffset() {\n      return this.clientRect.left;\n    }\n    get size() {\n      return this.thumbElement.clientWidth;\n    }\n    updateStyles(position, size) {\n      this.thumbElement.style.width = `${size}px`;\n      this.thumbElement.style.transform = `translate3d(${position}px, 0, 0)`;\n    }\n    handleDrag(position, scrollMax) {\n      if (this.dir.value === 'rtl') {\n        if (this.cmp.manager.rtlScrollAxisType === 1 /* NEGATED */) {\n          return position - scrollMax;\n        }\n        if (this.cmp.manager.rtlScrollAxisType === 2 /* INVERTED */) {\n          return scrollMax - position;\n        }\n        // Keeping this as a memo\n        // if (this.rtlScrollAxisType === RtlScrollAxisType.NORMAL) {\n        //   return position;\n        // }\n      }\n\n      return position;\n    }\n    handleDirection(position, trackMax) {\n      if (this.dir.value === 'rtl') {\n        if (this.cmp.manager.rtlScrollAxisType === 2 /* INVERTED */) {\n          return -position;\n        }\n        if (this.cmp.manager.rtlScrollAxisType === 0 /* NORMAL */) {\n          return position - trackMax;\n        }\n        // Keeping this as a memo\n        // if (this.rtlScrollAxisType === RtlScrollAxisType.NEGATED) {\n        //   return position;\n        // }\n      }\n\n      return position;\n    }\n    setDragging(value) {\n      this.cmp.setDragging({\n        horizontalDragging: value\n      });\n    }\n    scrollTo(position) {\n      this.cmp.viewport.scrollXTo(position);\n    }\n  }\n  ThumbXDirective.ɵfac = function ThumbXDirective_Factory(t) {\n    return new (t || ThumbXDirective)(ɵngcc0.ɵɵdirectiveInject(NgScrollbar), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Directionality));\n  };\n  ThumbXDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ThumbXDirective,\n    selectors: [[\"\", \"scrollbarThumbX\", \"\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return ThumbXDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ThumbYDirective = /*#__PURE__*/(() => {\n  class ThumbYDirective extends ThumbAdapter {\n    constructor(cmp, element, document) {\n      super(cmp, element.nativeElement, document);\n      this.cmp = cmp;\n      this.element = element;\n      this.document = document;\n    }\n    get pageProperty() {\n      return 'pageY';\n    }\n    get viewportScrollSize() {\n      return this.cmp.viewport.scrollHeight;\n    }\n    get viewportScrollOffset() {\n      return this.cmp.viewport.scrollTop;\n    }\n    get viewportScrollMax() {\n      return this.cmp.viewport.scrollMaxY;\n    }\n    get clientProperty() {\n      return 'clientY';\n    }\n    get dragStartOffset() {\n      return this.clientRect.top;\n    }\n    get size() {\n      return this.thumbElement.clientHeight;\n    }\n    updateStyles(position, size) {\n      this.thumbElement.style.height = `${size}px`;\n      this.thumbElement.style.transform = `translate3d(0px, ${position}px, 0)`;\n    }\n    handleDrag(position) {\n      return position;\n    }\n    handleDirection(position) {\n      return position;\n    }\n    setDragging(value) {\n      this.cmp.setDragging({\n        verticalDragging: value\n      });\n    }\n    scrollTo(position) {\n      this.cmp.viewport.scrollYTo(position);\n    }\n  }\n  ThumbYDirective.ɵfac = function ThumbYDirective_Factory(t) {\n    return new (t || ThumbYDirective)(ɵngcc0.ɵɵdirectiveInject(NgScrollbar), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n  ThumbYDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: ThumbYDirective,\n    selectors: [[\"\", \"scrollbarThumbY\", \"\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return ThumbYDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TrackXDirective = /*#__PURE__*/(() => {\n  class TrackXDirective extends TrackAdapter {\n    constructor(cmp, trackElement, document) {\n      super(cmp, trackElement.nativeElement, document);\n      this.cmp = cmp;\n      this.document = document;\n    }\n    get pageProperty() {\n      return 'pageX';\n    }\n    get offset() {\n      return this.clientRect.left;\n    }\n    get size() {\n      return this.trackElement.clientWidth;\n    }\n    mapToScrollToOption(value) {\n      return {\n        left: value\n      };\n    }\n  }\n  TrackXDirective.ɵfac = function TrackXDirective_Factory(t) {\n    return new (t || TrackXDirective)(ɵngcc0.ɵɵdirectiveInject(NgScrollbar), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n  TrackXDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TrackXDirective,\n    selectors: [[\"\", \"scrollbarTrackX\", \"\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return TrackXDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TrackYDirective = /*#__PURE__*/(() => {\n  class TrackYDirective extends TrackAdapter {\n    constructor(cmp, trackElement, document) {\n      super(cmp, trackElement.nativeElement, document);\n      this.cmp = cmp;\n      this.document = document;\n    }\n    get pageProperty() {\n      return 'pageY';\n    }\n    get offset() {\n      return this.clientRect.top;\n    }\n    get size() {\n      return this.trackElement.clientHeight;\n    }\n    mapToScrollToOption(value) {\n      return {\n        top: value\n      };\n    }\n  }\n  TrackYDirective.ɵfac = function TrackYDirective_Factory(t) {\n    return new (t || TrackYDirective)(ɵngcc0.ɵɵdirectiveInject(NgScrollbar), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT));\n  };\n  TrackYDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: TrackYDirective,\n    selectors: [[\"\", \"scrollbarTrackY\", \"\"]],\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature]\n  });\n  return TrackYDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet Scrollbar = /*#__PURE__*/(() => {\n  class Scrollbar {\n    constructor(cmp, platform, document, zone) {\n      this.cmp = cmp;\n      this.platform = platform;\n      this.document = document;\n      this.zone = zone;\n      // Stream that emits to unsubscribe from all streams\n      this.destroyed = new Subject();\n    }\n    /**\n     * Activate scrollbar pointer events\n     */\n    activatePointerEvents() {\n      // Stream that emits when scrollbar thumb is dragged\n      let thumbDragEvent = EMPTY;\n      // Stream that emits when scrollbar track is clicked\n      let trackClickEvent = EMPTY;\n      // Stream that emits when scrollbar track is hovered\n      let trackHoveredEvent = EMPTY;\n      // Set the method used for the pointer events option\n      if (this.cmp.pointerEventsMethod === 'viewport') {\n        // Pointer events using the viewport\n        this.viewportTrackClicked = new Subject();\n        this.viewportThumbClicked = new Subject();\n        // Activate the pointer events of the viewport directive\n        this.cmp.viewport.activatePointerEvents(this.cmp.viewportPropagateMouseMove, this.destroyed);\n        // Set streams\n        thumbDragEvent = this.viewportThumbClicked;\n        trackClickEvent = this.viewportTrackClicked;\n        trackHoveredEvent = this.cmp.viewport.hovered.pipe(\n        // Check if track is hovered\n        map(e => isWithinBounds(e, this.track.clientRect)), distinctUntilChanged(),\n        // Enable / disable text selection\n        tap(hovered => this.document.onselectstart = hovered ? () => false : null));\n        this.cmp.viewport.clicked.pipe(tap(e => {\n          if (e) {\n            if (isWithinBounds(e, this.thumb.clientRect)) {\n              this.viewportThumbClicked.next(e);\n            } else if (isWithinBounds(e, this.track.clientRect)) {\n              this.cmp.setClicked(true);\n              this.viewportTrackClicked.next(e);\n            }\n          } else {\n            this.cmp.setClicked(false);\n          }\n        }), takeUntil(this.destroyed)).subscribe();\n      } else {\n        // Pointer events method is using 'scrollbar'\n        thumbDragEvent = this.thumb.clicked;\n        trackClickEvent = this.track.clicked;\n        trackHoveredEvent = this.track.hovered;\n      }\n      return merge(\n      // Activate scrollbar hovered event\n      trackHoveredEvent.pipe(tap(e => this.setHovered(e))),\n      // Activate scrollbar thumb drag event\n      thumbDragEvent.pipe(switchMap(e => this.thumb.dragged(e))),\n      // Activate scrollbar track click event\n      trackClickEvent.pipe(switchMap(e => this.track.onTrackClicked(e, this.thumb.size, this.viewportScrollSize))));\n    }\n    ngOnInit() {\n      this.zone.runOutsideAngular(() => {\n        // Activate pointer events on Desktop only\n        if (!(this.platform.IOS || this.platform.ANDROID) && !this.cmp.pointerEventsDisabled) {\n          this.activatePointerEvents().pipe(takeUntil(this.destroyed)).subscribe();\n        }\n        // Stream that emits when host component is updated\n        const updated = this.cmp.updated.pipe(tap(() => this.onUpdated()));\n        // Update scrollbar thumb when viewport is scrolled and when scrollbar component is updated\n        merge(this.cmp.scrolled, updated).pipe(tap(() => this.thumb.update()), takeUntil(this.destroyed)).subscribe();\n        // Initialize scrollbar\n        asyncScheduler.schedule(() => this.thumb.update(), 100);\n      });\n    }\n    ngOnDestroy() {\n      this.destroyed.next();\n      this.destroyed.complete();\n      // Clean up viewport streams if used\n      if (this.viewportThumbClicked && this.viewportTrackClicked) {\n        this.viewportTrackClicked.complete();\n        this.viewportThumbClicked.complete();\n      }\n    }\n  }\n  Scrollbar.ɵfac = function Scrollbar_Factory(t) {\n    return new (t || Scrollbar)(ɵngcc0.ɵɵdirectiveInject(NgScrollbar), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Platform), ɵngcc0.ɵɵdirectiveInject(undefined), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n  Scrollbar.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: Scrollbar\n  });\n  return Scrollbar;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ScrollbarY = /*#__PURE__*/(() => {\n  class ScrollbarY extends Scrollbar {\n    constructor(cmp, platform, document, zone) {\n      super(cmp, platform, document, zone);\n      this.cmp = cmp;\n      this.platform = platform;\n      this.document = document;\n      this.zone = zone;\n    }\n    get viewportScrollSize() {\n      return this.cmp.viewport.scrollHeight;\n    }\n    setHovered(value) {\n      this.cmp.setHovered({\n        verticalHovered: value\n      });\n    }\n    onUpdated() {}\n  }\n  ScrollbarY.ɵfac = function ScrollbarY_Factory(t) {\n    return new (t || ScrollbarY)(ɵngcc0.ɵɵdirectiveInject(NgScrollbar), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Platform), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n  ScrollbarY.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ScrollbarY,\n    selectors: [[\"scrollbar-y\"]],\n    viewQuery: function ScrollbarY_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(TrackYDirective, 7);\n        ɵngcc0.ɵɵviewQuery(ThumbYDirective, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.track = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumb = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function ScrollbarY_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"scrollbar-control\", true);\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 7,\n    consts: [[\"scrollbarTrackY\", \"\"], [\"scrollbarThumbY\", \"\", 3, \"track\"]],\n    template: function ScrollbarY_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelement(1, \"div\", 1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMapInterpolate1(\"ng-scrollbar-track \", ctx.cmp.trackClass, \"\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassMapInterpolate1(\"ng-scrollbar-thumb \", ctx.cmp.thumbClass, \"\");\n        ɵngcc0.ɵɵproperty(\"track\", ctx.track);\n      }\n    },\n    dependencies: [ThumbYDirective, TrackYDirective],\n    styles: [\".ng-scrollbar-wrapper>scrollbar-y.scrollbar-control{width:var(--vertical-scrollbar-total-size)}  .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track{height:calc(100% - var(--scrollbar-padding)*2);width:var(--vertical-scrollbar-size)}  .ng-scrollbar-wrapper>scrollbar-y.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{height:0;width:100%}  .ng-scrollbar-wrapper[verticalDragging=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb,   .ng-scrollbar-wrapper[verticalHovered=true]>scrollbar-y.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}  .ng-scrollbar-wrapper[deactivated=false]>scrollbar-y.scrollbar-control{bottom:0;top:0}  .ng-scrollbar-wrapper[deactivated=false][dir=ltr]>scrollbar-y.scrollbar-control{left:unset;right:0}  .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertAll]>scrollbar-y.scrollbar-control,   .ng-scrollbar-wrapper[deactivated=false][dir=ltr][position=invertY]>scrollbar-y.scrollbar-control,   .ng-scrollbar-wrapper[deactivated=false][dir=rtl]>scrollbar-y.scrollbar-control{left:0;right:unset}  .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertAll]>scrollbar-y.scrollbar-control,   .ng-scrollbar-wrapper[deactivated=false][dir=rtl][position=invertY]>scrollbar-y.scrollbar-control{left:unset;right:0}  .ng-scrollbar-wrapper[deactivated=false][track=all]>scrollbar-y.scrollbar-control[fit=true]{bottom:var(--scrollbar-total-size);top:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertAll]>scrollbar-y.scrollbar-control[fit=true],   .ng-scrollbar-wrapper[deactivated=false][track=all][position=invertX]>scrollbar-y.scrollbar-control[fit=true]{bottom:0;top:var(--scrollbar-total-size)}\"],\n    changeDetection: 0\n  });\n  return ScrollbarY;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ScrollbarX = /*#__PURE__*/(() => {\n  class ScrollbarX extends Scrollbar {\n    constructor(el, cmp, platform, document, zone) {\n      super(cmp, platform, document, zone);\n      this.el = el;\n      this.cmp = cmp;\n      this.platform = platform;\n      this.document = document;\n      this.zone = zone;\n    }\n    get viewportScrollSize() {\n      return this.cmp.viewport.scrollWidth;\n    }\n    get thickness() {\n      return this.el.nativeElement.clientHeight;\n    }\n    setHovered(value) {\n      this.cmp.setHovered({\n        horizontalHovered: value\n      });\n    }\n    onUpdated() {\n      // Auto-height: Set root component height to content height\n      this.cmp.nativeElement.style.height = this.cmp.appearance === 'standard' ? `${this.cmp.viewport.contentHeight + this.thickness}px` : `${this.cmp.viewport.contentHeight}px`;\n    }\n  }\n  ScrollbarX.ɵfac = function ScrollbarX_Factory(t) {\n    return new (t || ScrollbarX)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(NgScrollbar), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Platform), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone));\n  };\n  ScrollbarX.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: ScrollbarX,\n    selectors: [[\"scrollbar-x\"]],\n    viewQuery: function ScrollbarX_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(TrackXDirective, 7);\n        ɵngcc0.ɵɵviewQuery(ThumbXDirective, 7);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.track = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.thumb = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function ScrollbarX_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassProp(\"scrollbar-control\", true);\n      }\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature],\n    decls: 2,\n    vars: 7,\n    consts: [[\"scrollbarTrackX\", \"\"], [\"scrollbarThumbX\", \"\", 3, \"track\"]],\n    template: function ScrollbarX_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\n        ɵngcc0.ɵɵelement(1, \"div\", 1);\n        ɵngcc0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        ɵngcc0.ɵɵclassMapInterpolate1(\"ng-scrollbar-track \", ctx.cmp.trackClass, \"\");\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵclassMapInterpolate1(\"ng-scrollbar-thumb \", ctx.cmp.thumbClass, \"\");\n        ɵngcc0.ɵɵproperty(\"track\", ctx.track);\n      }\n    },\n    dependencies: [ThumbXDirective, TrackXDirective],\n    styles: [\".ng-scrollbar-wrapper>scrollbar-x.scrollbar-control{height:var(--horizontal-scrollbar-total-size)}  .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track{height:var(--horizontal-scrollbar-size);width:calc(100% - var(--scrollbar-padding)*2)}  .ng-scrollbar-wrapper>scrollbar-x.scrollbar-control>.ng-scrollbar-track>.ng-scrollbar-thumb{height:100%;width:0}  .ng-scrollbar-wrapper[horizontalDragging=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb,   .ng-scrollbar-wrapper[horizontalHovered=true]>scrollbar-x.scrollbar-control .ng-scrollbar-thumb{background-color:var(--scrollbar-thumb-hover-color)}  .ng-scrollbar-wrapper[position=invertAll]>scrollbar-x.scrollbar-control,   .ng-scrollbar-wrapper[position=invertX]>scrollbar-x.scrollbar-control{bottom:unset;top:0}  .ng-scrollbar-wrapper[deactivated=false]>scrollbar-x.scrollbar-control{bottom:0;left:0;right:0;top:unset}  .ng-scrollbar-wrapper[deactivated=false][position=invertAll]>scrollbar-x.scrollbar-control,   .ng-scrollbar-wrapper[deactivated=false][position=invertX]>scrollbar-x.scrollbar-control{bottom:unset;top:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr]>scrollbar-x.scrollbar-control[fit=true]{left:0;right:var(--scrollbar-total-size)}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertAll]>scrollbar-x.scrollbar-control[fit=true],   .ng-scrollbar-wrapper[deactivated=false][track=all][dir=ltr][position=invertY]>scrollbar-x.scrollbar-control[fit=true],   .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl]>scrollbar-x.scrollbar-control[fit=true]{left:var(--scrollbar-total-size);right:0}  .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertAll]>scrollbar-x.scrollbar-control[fit=true],   .ng-scrollbar-wrapper[deactivated=false][track=all][dir=rtl][position=invertY]>scrollbar-x.scrollbar-control[fit=true]{left:0;right:var(--scrollbar-total-size)}\"],\n    changeDetection: 0\n  });\n  return ScrollbarX;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgScrollbarModule = /*#__PURE__*/(() => {\n  class NgScrollbarModule {\n    static withConfig(options) {\n      return {\n        ngModule: NgScrollbarModule,\n        providers: [{\n          provide: NG_SCROLLBAR_OPTIONS,\n          useValue: options\n        }]\n      };\n    }\n  }\n  NgScrollbarModule.ɵfac = function NgScrollbarModule_Factory(t) {\n    return new (t || NgScrollbarModule)();\n  };\n  NgScrollbarModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgScrollbarModule\n  });\n  NgScrollbarModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [CommonModule, BidiModule, PortalModule, PlatformModule, SmoothScrollModule]\n  });\n  return NgScrollbarModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgScrollbarModule, {\n    declarations: function () {\n      return [NgScrollbar, ScrollViewport, HideNativeScrollbar, NgAttr, ResizeSensor, ThumbYDirective, ThumbXDirective, TrackXDirective, TrackYDirective, ScrollbarY, ScrollbarX];\n    },\n    imports: function () {\n      return [CommonModule, BidiModule, PortalModule, PlatformModule, SmoothScrollModule];\n    },\n    exports: function () {\n      return [NgScrollbar, ScrollViewport];\n    }\n  });\n})();\n\n/*\n * Public API Surface of ngx-scrollbar\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NG_SCROLLBAR_OPTIONS, NgScrollbar, NgScrollbarModule, ScrollViewport, ScrollbarManager, HideNativeScrollbar as ɵa, NativeScrollbarSizeFactory as ɵb, NgAttr as ɵc, ResizeObserverFactory as ɵd, ResizeSensor as ɵe, ThumbXDirective as ɵf, ThumbYDirective as ɵg, ThumbAdapter as ɵh, TrackXDirective as ɵi, TrackYDirective as ɵj, TrackAdapter as ɵk, ScrollbarY as ɵl, ScrollbarX as ɵm, Scrollbar as ɵn };\n\n//# sourceMappingURL=ngx-scrollbar.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}